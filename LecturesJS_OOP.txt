Евлоги - първа лекция за функции - деклариране, експрешънс, iife

Функцията е обект. Параметрите могат да бъдат от различни типове.

Всяка функция си има вградени СПЕЦИАЛНИ обекти - arguments and this
arguments - contains all passed arguments; this contains information about the context. Тук има различни значения. 

Всяка функция връща нещо ако нищо не връща, то е undefined. Може да връща стойност, както и друга функция, масив.... 
Обекта на функцията - функцията е обект.  First-class functions in JS. Те могат да бъдат асайнати/присвоени на променливи или пропертита, да се подават като аргументи или да се връщат като резултат от други функции. 

Функциите в JS имат свои собствени свойства: length(брой на аргументите), caller, name, apply, call. 

Създаване на функции: Function declaration - тук функцията задължително трябва да има име/по-добре е. Може да се извикват отвсякъде/дори преди да са декларирани/. function printMsg (msg) {console.log(msg);}

Function expression:  var printMsg = function (msg) {console.log(msg);} извикват се след декларирането на ф-ята

Function constructor: var printMsg = new Function("msg", 'console.log("msg");'); за динамично създаване на функции. 

В JS постоянно си дебъгвайте. Това е особено важно за JS. Дали в браузъра - неговата конзола или направо в cmd Често да проверяваме какво става, какво сме направили. дали поведението на функцията е това, което очакваме. 

При function expressions ако нямат име, когато нещо ни гърми, няма да знаем коя функция гърми. Затова е по-добре и на тях да слагаме име, а не да са анонимни. 

При function constructor също можем да работим с нея чак след като сме я дефинирали. Декларира се, като първо се подават аргументите, а после тялото на функцията - всичко е като стрингове, които се конкатенират. 
max = new Function(maxParams, maxBody); maxParams = '...  '; maxBody = '...' + '...'+ ...; По-рядко се използват

Пропертита, които има функцията: length - броя на аргументите на функцията. Така отвън можем да разберем с колко параметъра е функцията - име.length - дава броя аргументи. Иначе вътре в самата функция може да го разберем чрез console.log(arguments.length ); arguments.callee - това е референция към самата функция; може да се ползва при рекурсия, тъй като това ще ни извика самата функция. 

function.name - връща ни името на функцията. Методите на функция са:
function.toString(); връща тялото на самата функция като текст.   
function.call(obj, args)  obj - върху какъв обект да се приложи функцията; като се прилага с подадените аргументи. 
function.apply(obj, [arg1, arg2, ...]) arguments are given as array. 

Прави функция, която да събира всичко, независимо какви са аргументите :
function sum(){
	var i,
	     sum=0;
		len = arguments.length;
for (i=0; i < len; i+=1){
	sum += +arguments[i];
	}
    return sum; 
}
console.log(sum(1, '2', 3, '-5'));   и изкарва 1, т.е. работи. Но интересното е че итерира по дължината на arguments.

.apply .call - извикват самата функция, като могат да й променят контекста, това им е силата. Единия работи с масив, а другия с поредица от аргументи. Когато имаме различен контекст с this тогава променят поведението на функцията.

Рекурсия - важно е демото за обхождане на ДОМ дървото. 

IIFE - деклариране по няколко начина: като модул - с име var module/iife = (function () {.....}()); Така може да се вика отвън. отдолу и с точкова нотация да се достъпи, това което връща iife-то. Създава скоуп, който да не замърсява глобалния скоуп. 

Скоуп и Кложър лекция Дончо

Ако функицята не се намира в някакво иифи, то тя е в глобалния скоуп. И може да се достъпва отвсякъде. Аргументите на функцията обаче са в нейния, но не в глобалния скоуп. Ако на една променлива изпуснем var тя отива в глобалния скоуп. Колкото по-малко позваме глобалния скоуп, толкова по-добре. Всяка програма да е в 1 голямо иифи. Другият скоуп е функционалния скоуп.  Тук нямаме друг скоуп, който да се създава от къдравите скоби. т.е. циклите и иф-овете не правят скоуп. Когато напишем var променливата след това се измества най-отгоре на текущия скоуп. В JS няма проблем да имаме променливи с едно име, стига да са в различен скоуп. В ECMAScript 6 let е като var; създава блоков скоуп. Все още не се поддържа навсякъде.  









