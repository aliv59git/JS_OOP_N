Евлоги - първа лекция за функции - деклариране, експрешънс, iife

Функцията е обект. Параметрите могат да бъдат от различни типове.

Всяка функция си има вградени СПЕЦИАЛНИ обекти - arguments and this
arguments - contains all passed arguments; this contains information about the context. Тук има различни значения. 

Всяка функция връща нещо ако нищо не връща, то е undefined. Може да връща стойност, както и друга функция, масив.... 
Обекта на функцията - функцията е обект.  First-class functions in JS. Те могат да бъдат асайнати/присвоени на променливи или пропертита, да се подават като аргументи или да се връщат като резултат от други функции. 

Функциите в JS имат свои собствени свойства: length(брой на аргументите), caller, name, apply, call. 

Създаване на функции: Function declaration - тук функцията задължително трябва да има име/по-добре е. Може да се извикват отвсякъде/дори преди да са декларирани/. function printMsg (msg) {console.log(msg);}

Function expression:  var printMsg = function (msg) {console.log(msg);} извикват се след декларирането на ф-ята

Function constructor: var printMsg = new Function("msg", 'console.log("msg");'); за динамично създаване на функции. 

В JS постоянно си дебъгвайте. Това е особено важно за JS. Дали в браузъра - неговата конзола или направо в cmd Често да проверяваме какво става, какво сме направили. дали поведението на функцията е това, което очакваме. 

При function expressions ако нямат име, когато нещо ни гърми, няма да знаем коя функция гърми. Затова е по-добре и на тях да слагаме име, а не да са анонимни. 

При function constructor също можем да работим с нея чак след като сме я дефинирали. Декларира се, като първо се подават аргументите, а после тялото на функцията - всичко е като стрингове, които се конкатенират. 
max = new Function(maxParams, maxBody); maxParams = '...  '; maxBody = '...' + '...'+ ...; По-рядко се използват

Пропертита, които има функцията: length - броя на аргументите на функцията. Така отвън можем да разберем с колко параметъра е функцията - име.length - дава броя аргументи. Иначе вътре в самата функция може да го разберем чрез console.log(arguments.length ); arguments.callee - това е референция към самата функция; може да се ползва при рекурсия, тъй като това ще ни извика самата функция. 

function.name - връща ни името на функцията. Методите на функция са:
function.toString(); връща тялото на самата функция като текст.   
function.call(obj, args)  obj - върху какъв обект да се приложи функцията; като се прилага с подадените аргументи. 
function.apply(obj, [arg1, arg2, ...]) arguments are given as array. 

Прави функция, която да събира всичко, независимо какви са аргументите :
function sum(){
	var i,
	     sum=0;
		len = arguments.length;
for (i=0; i < len; i+=1){
	sum += +arguments[i];
	}
    return sum; 
}
console.log(sum(1, '2', 3, '-5'));   и изкарва 1, т.е. работи. Но интересното е че итерира по дължината на arguments.

.apply .call - извикват самата функция, като могат да й променят контекста, това им е силата. Единия работи с масив, а другия с поредица от аргументи. Когато имаме различен контекст с this тогава променят поведението на функцията.

Рекурсия - важно е демото за обхождане на ДОМ дървото: 

function traverse(node) {
	traverseNode(node, '');

	function traverseNode(node, spacing) {
		var i,
			len,
			child;
		spacing = spacing || '  ';
		console.log(spacing + node.nodeName);
		for (i = 0, len = node.childNodes.length; i < len; i += 1) {
			child = node.childNodes[i];
			if (child.nodeType === 1) {
				traverseNode(child, spacing + '  ');
			}
		}
		console.log(spacing + '/' + node.nodeName);
	}
}

traverse(document.documentElement);

IIFE - деклариране по няколко начина: като модул - с име var module/iife = (function () {.....}()); Така може да се вика отвън. отдолу и с точкова нотация да се достъпи, това което връща iife-то. Създава скоуп, който да не замърсява глобалния скоуп. 

II лекция: Скоуп и Кложър лекция Дончо

Ако функицята не се намира в някакво иифи, то тя е в глобалния скоуп. И може да се достъпва отвсякъде. Аргументите на функцията обаче са в нейния, но не в глобалния скоуп. Ако на една променлива изпуснем var тя отива в глобалния скоуп. Колкото по-малко позваме глобалния скоуп, толкова по-добре. Всяка програма да е в 1 голямо иифи. Другият скоуп е функционалния скоуп.  Тук нямаме друг скоуп, който да се създава от къдравите скоби. т.е. циклите и иф-овете не правят скоуп. Когато напишем var променливата след това се измества най-отгоре на текущия скоуп. В JS няма проблем да имаме променливи с едно име, стига да са в различен скоуп. В ECMAScript 6 let е като var; създава блоков скоуп. Все още не се поддържа навсякъде.  


III. Класическо наследяване в JavaScript





<<<<<<< HEAD
V. Разглеждане вкъщи лекцията и презентацията Prototype Inheritance and Duck Typing
=======
IV. Разглеждане вкъщи лекцията и презентацията Prototype Inheritance and Duck Typing
>>>>>>> fb514cff3ef210f45d006aa75b910ac04716eed4

Прототипът е обект, който дава свойства/properties на своите наследители. Всеки обект има свой собствен прототип. By default, set to Object.prototype. Това формира така наречената "Прототипна верига". Object има прототип null, завършвайки прототипната верига

Всеки JS обект има property .__proto__  То може да се използва да се достъпи/да се промени прототипа. Когато сетваме прототипа на обекта, обектът има достъп до всички property -та  на прототипа.  Наследяването e с реда:

dog.__proto__ = animal;   //тогава dog ще има достъп до пропертитата на парента    
dog.makeNoise();  //през прототипната верига се достъпва проперти на парента. Това се нарича Прототипно наследяване (Prototypal Inheritance).

var animal = {			//Setting the Prototype with __proto__
    makeNoise: function(){
	console.log('The ' + this.type + 'makesnoise" '+ this.noise + ' " ');
    }
};
var dog = { type: 'dog', noise: 'Djaff' }'
dog.__proto__ = animal;
dog.makeNoise();   // makeNoise() is from the prototype(animal);  

Setting Prototypes with Object.create() -> The better way to work with protorypes

var animal = {				//the same:     var animal = {	
  //properties and methods				             //properties and methods
};						       };
var dog = Object.create(animal);			var dog = {
dog.type = 'dog';					    type: 'dog',
dog.noise = 'djaff';					    noise: 'djaff'
						};
						dog.__proto__ = animal;
Working with Object Protorypes
Object.create()  е добре но не е добре да се добавят пропертита с точкова нотация. Това се решава с Object.defineProperties(): 
var dog = (function (parent){
    var dog = Object.defineProperties(parent, {
         type: {
	value: 'dog'
         },
           noise: {
               	value: 'djaff'
         }
    });
    return dog;
}(animal));

Reusing Parent Methods - Използването на парент методите е важно, решаващо за всеки ООП дизайн. Благодарение на това има
Function.protorype.call(this, ... ) and Function.prototype.apply(this, ... ); .... са пре- дефинираните в парента пропертита. 

Duck Typing 

Duck Typing-а е слой от програмния език и правилата за дизайн в началото на проекта/писането/.  Писането се засяга/влияе от типа на всеки обект, т.е. методи работят с обекти от някакъв тип. Дък тайпингът се засяга от установяването на подготящността на обект за дадена цел. т.е. методи с обект който има някакви пропертита.  

Exceptions in JS Лекция на Дончо. 25.06.15

Най-чести са синтактичните грешки - нещо не е написано както трябва според изискванията на езика, 

Референс ексепшънс - опитваме се да правим нещо с undefined - 

За прихващане на грешките - try - catch  блокове

Като се хвърли ексепшън, спира изпълнението на цялата програма. Когато обаче е в try - catch блок, показва грешката и продължава изпълнението на програмата. 

Ексепшъните са информация за девелопърите. Ексепшъните се казват Error ReferenceError, SyntaxError; 	 TypeError 

Лекция: Object and Object.prototype methods

Object Methods:

Object.defineProperty(obj, prop, descriptor)
Object.defineProperties()
Object.create()
Object.keys()
Object.preventExtensions()
Oject.isExtensible()
Object.isSeal()
Object.isSealed()
Object.isFreeze()
Object.isFrozen()
Object.assign()
Object.is()

Object.prototype Methods: 
Object.prototype.hasOwnProperty()
Object.prototype.isPropertyOf()
Object.prototype.propertyEnumerable()
Object.prototype.valueOf()







V. JS Patterns - пета лекция

var controls = (function (){
  function formatResult(name, value){
    return name + ' says the result is ' + value;
  }
  var calculator = {
    init: function (name){
      this.name = name;
      this.result = 0;
      return this;
    },
    add: function (x){
      x = +x;
      this.result += x;
      return this;
    },
    substract: function (x){
      x = +x;
      this.result -= x;
      return this;
    }, 
    showResult: function () {
      console.log(formatResult(this.name, this.result));
      return this;
    }
  };
  return {
    getCalculator: function (name){
      return Object.create(calculator).init(name);
    }
  };
}());
controls.getCalculator('First').add(7).showResult().substract(2).showResult();

Модул патерна осигурява капсулиране на променливи и функции;
Дава начин за добавяне на видимост (public versus private) на членовете;
Всяка инстанция на обекта създава ново копие на функцията в паметта.

Revealing Module Pattern: Pros and Cons		Pros:  Модуларизира кода в ре-юзъбъл обекти;
	Променливи/функции взети извън глобалния неймспейс.
	Показва само видимите членове.
	"Cleaner" way to exposure members; Лесно за промяна на members privacy;
Cons: No easy to extend; Some complain about debugging; Hard to mock hidden objects for testing;

var module = (function () {		//Структура:
	//hidden variables    //hidden functions
	return{
		//visible members
		someFunc: referenceToFunction
		anotherFunc: referenceToOtherFunction
	};
}()); 

.............(като модул патърна по-горе) различие: //returns ony a reference to the function
  return {	   //фукцията getCalculator(name) остава скрита /hidden/ за разлика от модул патерна, където е видима. 
    getCalculator: getCalculator
  };
}());
var calc = controls.getCalculator('First');
calc.add(7+5);
calc.showResult();
calc.substract(11);
calc.showResult();

Singleton Pattern

var module = function() {		//Structure:
   var instance =  { /* code for instance*/};
   instance = Object.preventExtensions(instance);
	return {
	   get: function() {	
		return instance;
	   }
	};
}();
	Example: 
var calculator = function (){
  var calculator = Object.preventExtensions({
    result: 0,
    add: function(x){
      calculator.result += +x;
      return calculator;
    },
    substract: function(x){
      calculator.result -= +x;
      return calculator;
    },
    showResult: function(){
      console.log('The result is: ' + calculator.result);
      return calculator;
    }
  });
  return {
    get: function (){
      return calculator;
    }
  };
}();
calculator.get().add(7).substract(-12).showResult();  //19

Augmenting Modules Увеличаващи се, уголемяващи се модули
Означава разделяне на бодули на много файлове/ИИФИ-та. 




































